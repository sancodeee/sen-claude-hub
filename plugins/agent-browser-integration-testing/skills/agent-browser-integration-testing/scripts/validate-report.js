#!/usr/bin/env node

/**
 * @fileoverview Integration Test Report Validator
 *
 * This script validates the structure and content of integration test reports
 * generated by the agent-browser-integration-testing skill.
 *
 * Validation Rules:
 * 1. Header fields must be present and filled (requirement, URL, date, status, duration)
 * 2. Sections must be present in the correct order (1-6 with 4.1/4.2/4.3 subsections)
 * 3. Execution log must have at least open step and a final filled step
 * 4. Evidence section must contain images with captions
 * 5. Network audit 4.1 must only contain xhr/fetch requests
 * 6. Non-2xx APIs in 4.1 must have corresponding details in 4.2
 * 7. No <<FILL: ...>> placeholders should remain in the final report
 *
 * Exit Codes:
 * - 0: Validation passed
 * - 1: Validation failed (errors found in report)
 * - 2: Script error (file not found, usage error, etc.)
 *
 * @example
 * // Run validation
 * node scripts/validate-report.js testing-report/report-20260212/report.md
 *
 * @author agent-browser-integration-testing skill
 * @version 1.0.0
 */

const fs = require("fs");

// ============================================================================
// Argument Parsing
// ============================================================================

const reportPath = process.argv[2];
if (!reportPath) {
    console.error("Usage: node scripts/validate-report.js <report-path>");
    console.error("");
    console.error("Example: node scripts/validate-report.js testing-report/report.md");
    process.exit(2);
}

// ============================================================================
// File Reading
// ============================================================================

let content;
try {
    content = fs.readFileSync(reportPath, "utf8");
} catch (err) {
    console.error(`Failed to read report: ${err.message}`);
    console.error(`Suggestion: Check if the file path exists and is readable.`);
    process.exit(2);
}

// ============================================================================
// Error Collection
// ============================================================================

const errors = [];

// ============================================================================
// Validation Helper Functions
// ============================================================================

/**
 * Validates that the content matches a given regex pattern.
 * If not, adds an error message to the errors array.
 *
 * @param {RegExp} pattern - The regex pattern to test against content
 * @param {string} message - Error message to display if pattern doesn't match
 * @returns {void}
 *
 * @example
 * // Check for required header field
 * requireMatch(/^\*\*用户原始需求\*\*：\S/m, "Missing or empty: 用户原始需求");
 */
function requireMatch(pattern, message) {
    if (!pattern.test(content)) {
        errors.push(message);
    }
}

/**
 * Validates that multiple headers/sections appear in the correct order.
 * Each header must exist and appear after the previous one in the document.
 *
 * @param {string[]} headers - Array of headers/strings to check in order
 * @returns {void}
 *
 * @example
 * // Ensure sections appear in correct order
 * requireInOrder(["### 1. 测试摘要", "### 2. 关键发现", "### 3. 执行日志"]);
 */
function requireInOrder(headers) {
    let idx = -1;
    for (const h of headers) {
        const next = content.indexOf(h);
        if (next === -1) {
            errors.push(`Missing section: ${h}`);
            return;
        }
        if (next <= idx) {
            errors.push(`Section order incorrect: ${h} should appear after previous section`);
            return;
        }
        idx = next;
    }
}

/**
 * Extracts a section of content between two headers.
 * Used to isolate specific sections for detailed validation.
 *
 * @param {string} startHeader - The header marking the start of the section
 * @param {string|null} endHeader - The header marking the end of the section (null for end of document)
 * @returns {string|null} The extracted section content, or null if start header not found
 *
 * @example
 * // Get execution log section
 * const execSection = getSection("### 3. 执行日志", "### 4. 网络交互审计");
 */
function getSection(startHeader, endHeader) {
    const start = content.indexOf(startHeader);
    if (start === -1) {
        return null;
    }
    const end = endHeader ? content.indexOf(endHeader, start + startHeader.length) : -1;
    if (end === -1) {
        return content.slice(start);
    }
    return content.slice(start, end);
}

// ============================================================================
// Validation Rules
// ============================================================================

// -----------------------------------------------------------------------------
// Rule 1: Header Fields Validation
// Ensures all required header fields are present and contain non-empty values
// -----------------------------------------------------------------------------
requireMatch(/^\*\*用户原始需求\*\*：\S/m, "Missing or empty: 用户原始需求 (must have content after colon)");
requireMatch(/^\*\*目标 URL\*\*：\S/m, "Missing or empty: 目标 URL (must have URL after colon)");
requireMatch(/^\*\*日期与时间\*\*：\S/m, "Missing or empty: 日期与时间 (format: YYYY-MM-DD HH:MM:SS)");
requireMatch(/^\*\*总体状态\*\*：\s*(PASS|FAIL|WARN)\b/m, "Missing or invalid: 总体状态 (must be PASS, FAIL, or WARN)");
requireMatch(/^\*\*总耗时\*\*：\S/m, "Missing or empty: 总耗时 (format: X.X 秒)");

// -----------------------------------------------------------------------------
// Rule 2: Section Order Validation
// Ensures all required sections exist and are in the correct order
// -----------------------------------------------------------------------------
requireInOrder([
    "### 1. 测试摘要",
    "### 2. 关键发现",
    "### 3. 执行日志",
    "### 4. 网络交互审计",
    "#### 4.1 后端API接口调用概览",
    "#### 4.2 异常/关键接口详情",
    "#### 4.3 前端资源加载记录",
    "### 5. 举证",
    "### 6. 建议",
]);

// -----------------------------------------------------------------------------
// Rule 3: Execution Log Validation
// Ensures execution log has proper table structure with at least open and final step
// -----------------------------------------------------------------------------
// Check table header exists
requireMatch(
    /\|\s*步骤\s*\|\s*命令\s*\|\s*目标 \/ Ref\s*\|\s*状态\s*\|\s*耗时 \(秒\)\s*\|\s*详情 \/ 错误信息\s*\|/m,
    "Missing Execution Log table header (expected format: | 步骤 | 命令 | 目标 / Ref | 状态 | 耗时 (秒) | 详情 / 错误信息 |)"
);

// Check open step exists
requireMatch(/\|\s*\d+\s*\|\s*open\s*\|/m, "Execution Log must include open step (first step should be 'open')");

// Validate execution log content
const executionSection = getSection("### 3. 执行日志", "### 4. 网络交互审计");
if (executionSection) {
    // Parse all data rows from the execution log table
    const rowRegex = /^\|\s*(\d+)\s*\|\s*([^|]+?)\s*\|/gm;
    const rows = [];
    let match;
    while ((match = rowRegex.exec(executionSection)) !== null) {
        const step = match[1].trim();
        const command = match[2].trim();
        // Skip header row
        if (step !== "步骤") {
            rows.push({ step, command });
        }
    }

    // Must have at least 2 steps (open + at least one action)
    if (rows.length < 2) {
        errors.push("Execution Log must include at least two steps (open + at least one action)");
    } else {
        // Last step must be filled with a real command (not placeholder)
        const last = rows[rows.length - 1];
        if (!last.command || last.command.includes("<<FILL")) {
            errors.push("Execution Log last step must be filled with a real command (remove <<FILL: ...>> placeholder)");
        }
    }
}

// -----------------------------------------------------------------------------
// Rule 4: Final Page Info Validation
// Ensures final page title and URL are filled in evidence section
// -----------------------------------------------------------------------------
requireMatch(/^- \*\*最终页面标题\*\*：\S/m, "Missing or empty: 最终页面标题 (in section 5. 举证)");
requireMatch(/^- \*\*最终 URL\*\*：\S/m, "Missing or empty: 最终 URL (in section 5. 举证)");

// -----------------------------------------------------------------------------
// Rule 5: Placeholder Validation
// Ensures no unfilled placeholders remain in the report
// -----------------------------------------------------------------------------
if (content.includes("<<FILL:")) {
    errors.push("Report still contains <<FILL: ...>> placeholders (all placeholders must be replaced with actual values)");
}

// -----------------------------------------------------------------------------
// Rule 6: Evidence Section Validation
// Ensures evidence section has images with proper captions
// -----------------------------------------------------------------------------
const evidenceSection = getSection("### 5. 举证", "### 6. 建议");
if (!evidenceSection) {
    errors.push("Missing Evidence section (### 5. 举证)");
} else {
    // Check for embedded images using Markdown syntax
    const imageMatches = evidenceSection.match(/!\[[^\]]*\]\([^\)]+\)/g);
    if (!imageMatches || imageMatches.length === 0) {
        errors.push("Evidence section must include at least one embedded image via ![alt](path)");
    } else {
        // Check for captions in format *图X：...*
        const captionMatches = evidenceSection.match(/\*图\d+：.+\*/g);
        if (!captionMatches || captionMatches.length < imageMatches.length) {
            errors.push("Each evidence image must have a caption like *图X：description* (found " +
                (captionMatches ? captionMatches.length : 0) + " captions for " + imageMatches.length + " images)");
        }
    }
}

// -----------------------------------------------------------------------------
// Rule 7: Network Section Validation
// Validates API audit sections and cross-references non-2xx responses
// -----------------------------------------------------------------------------
const networkOverview = getSection("#### 4.1 后端API接口调用概览", "#### 4.2 异常/关键接口详情");
const networkDetails = getSection("#### 4.2 异常/关键接口详情", "#### 4.3 前端资源加载记录");

if (networkOverview) {
    // Parse API entries from 4.1 overview table
    // Format: | METHOD | /path | status | duration | result | description |
    const rowRegex = /^\|\s*([A-Z]+)\s*\|\s*([^|]+?)\s*\|\s*([0-9]{3})\s*\|/gm;
    const non2xx = [];
    let match;

    while ((match = rowRegex.exec(networkOverview)) !== null) {
        const method = match[1].trim();
        const path = match[2].trim();
        const status = match[3].trim();

        // Collect non-2xx status codes (4xx, 5xx)
        if (!/^2\d\d$/.test(status)) {
            non2xx.push({ method, path, status });
        }
    }

    // Ensure 4.2 section contains details for all non-2xx APIs found in 4.1
    if (non2xx.length > 0) {
        if (!networkDetails) {
            errors.push("Missing 4.2 details section (required when non-2xx APIs exist in 4.1)");
        } else {
            for (const item of non2xx) {
                const methodPath = `${item.method} ${item.path}`;
                // Check if both the endpoint and status code are mentioned in 4.2
                if (!networkDetails.includes(methodPath) || !networkDetails.includes(item.status)) {
                    errors.push(
                        `4.2 must include details for non-2xx API: ${methodPath} (Status: ${item.status}) - ` +
                        `found in 4.1 but missing detailed explanation in 4.2`
                    );
                }
            }
        }
    }
}

// ============================================================================
// Final Output
// ============================================================================

if (errors.length > 0) {
    console.error("========================================");
    console.error("REPORT VALIDATION FAILED");
    console.error("========================================");
    console.error("");
    console.error(`Found ${errors.length} error(s):`);
    console.error("");
    for (const err of errors) {
        console.error(`  ✗ ${err}`);
    }
    console.error("");
    console.error("Please fix the above issues before submitting the report.");
    console.error("Refer to references/REPORT_GUIDE.md for formatting guidelines.");
    process.exit(1);
}

console.log("========================================");
console.log("REPORT VALIDATION PASSED");
console.log("========================================");
console.log("");
console.log("All validation checks passed successfully.");
console.log(`Report: ${reportPath}`);
